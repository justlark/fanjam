use serde_json::json;

use crate::noco::{
    TableIds, list_tables,
    migrations::common::{CreateColumnRequest, ViewIds, create_columns, list_views, set_nop},
};

use super::{
    BaseId, Client, Version,
    common::{self, ColumnIds, EditColumnRequest, edit_columns, list_columns},
    n2,
};

const DATE_FORMAT: &str = "DD MMM YYYY";
const TIME_FORMAT: &str = "HH:mm";

// Metadata for DateTime columns
fn date_time_meta() -> serde_json::Value {
    json!({
        "date_format": DATE_FORMAT,
        "time_format": TIME_FORMAT,
        "is12hrFormat": true,
    })
}

pub struct Migration<'a> {
    client: &'a Client,
}

impl Migration<'_> {
    async fn edit_columns(&self, table_ids: &TableIds) -> anyhow::Result<()> {
        let events_columns = ColumnIds::from(list_columns(self.client, &table_ids.events).await?);
        let announcements_columns =
            ColumnIds::from(list_columns(self.client, &table_ids.announcements).await?);

        let event_start_time_column_id = events_columns.find_by_name("start_time")?;
        let event_end_time_column_id = events_columns.find_by_name("end_time")?;
        let description_column_id = events_columns.find_by_name("description")?;

        // These columns are generated by NocoDB and don't have column names.
        let announcement_created_column_id = announcements_columns.find_by_title("Created")?;
        let announcement_updated_column_id = announcements_columns.find_by_title("Last Edited")?;

        let requests = vec![
            EditColumnRequest {
                column_id: &event_start_time_column_id,
                body: json!({
                    "rqd": false,
                    "meta": date_time_meta(),
                }),
            },
            EditColumnRequest {
                column_id: &event_end_time_column_id,
                body: json!({
                    "meta": date_time_meta(),
                }),
            },
            EditColumnRequest {
                column_id: &description_column_id,
                body: json!({
                    "description": "A longer, more detailed description of the event.",
                }),
            },
            // For unknown and undocumented reasons, we need to specify the column titles again
            // here or they'll lose their titles.
            EditColumnRequest {
                column_id: &announcement_created_column_id,
                body: json!({
                    "title": "Created",
                    "meta": date_time_meta(),
                }),
            },
            EditColumnRequest {
                column_id: &announcement_updated_column_id,
                body: json!({
                    "title": "Last Edited",
                    "meta": date_time_meta(),
                }),
            },
        ];

        edit_columns(self.client, requests).await?;

        Ok(())
    }

    async fn create_columns(&self, table_ids: &TableIds) -> anyhow::Result<()> {
        let events_views = list_views(self.client, &table_ids.events).await?;
        let default_events_view_id =
            ViewIds::from(events_views).find_default().ok_or_else(|| {
                anyhow::anyhow!(
                    "No default view found for Events table `{}`",
                    table_ids.events
                )
            })?;

        let requests = vec![CreateColumnRequest {
            table_id: &table_ids.events,
            column_ref: set_nop(),
            body: json!({
                "column_name": "summary",
                "title": "Summary",
                "uidt": "LongText",
                "description": "A short summary of the event.",
                "column_order": {
                    "order": 2,
                    "view_id": default_events_view_id,
                },
                "meta": {
                    "richMode": false,
                },
            }),
        }];

        create_columns(self.client, requests).await?;

        Ok(())
    }
}

impl<'a> common::Migration<'a> for Migration<'a> {
    const INDEX: Version = n2::Migration::INDEX.next();

    fn new(client: &'a Client) -> Self {
        Self { client }
    }

    async fn migrate(&self, base_id: BaseId) -> anyhow::Result<()> {
        let tables = TableIds::try_from(list_tables(self.client, &base_id).await?)?;
        self.edit_columns(&tables).await?;
        self.create_columns(&tables).await?;

        Ok(())
    }
}
